
servers.py 入口做了修改,增加了config.py的参数配置，从中读取：是否需要以多线程模式运行和运行的线程数
MultiThread_ManagePort = True
ThreadNum_ManagePort = 8


dbtransfer.py 里面新加了方法，原有方法保留不变，调用新方法

原版是新开启了一个线程，专门来扫描users表里面所有的端口，管理他们的开通或者关闭
但是在用户数很多的情况下，3000个端口(用户)一个线程扫描完要5分钟左右，导致开通新账号或者续费非常慢

魔改版采用多线程处理，去管理端口
每一个线程管理属于它自己的那一堆账号(while true 轮询形式)
类似于mysql 分页一样 limit  offset

变量n就是线程数，直接修改它就可以获得更好的轮询性能(下面的mysql分页代码不用动)

主线程 + 八个轮询端口的线程 + 1个manager线程 + 一个轮询push流量的线程 = 11个线程
可以用 htop ,然后 F5 通过Tree 查看关系

根据目前的用户数来说(3300多个)，第8个线程应该没有去管理端口的，处于随时待命状态

# it will create like below
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-1-","limit 500 offset 0",))//thread 1 : 1-500
 time.sleep(1)
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-2-","limit 500 offset 500",))//thread 2 :501-1000
 time.sleep(1)
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-3-","limit 500 offset 1000",))//thread 3 :1001-1500
 time.sleep(1)
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-4-","limit 500 offset 1500",))//thread 4 :1501-2000
 time.sleep(1)
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-5-","limit 500 offset 2000",))//thread 5 :2001-2500
 time.sleep(1)
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-6-","limit 500 offset 2500",))//thread 6 :2501-3000
 time.sleep(1)
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-7-","limit 500 offset 3000",))//thread 7 :3001-3500
 time.sleep(1)
 t = thread.start_new_thread(DbTransfer.thread_db_with_parm, ("thread-8-","limit 100000 offset 3500",))//thread 8 :3501-100000






